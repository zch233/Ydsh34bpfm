"use strict";(self["webpackChunkvue2_cli5"]=self["webpackChunkvue2_cli5"]||[]).push([[32],{32032:function(e,t,n){n.r(t),n.d(t,{default:function(){return u}});var r=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},o=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("html",[n("head"),n("body",[n("blockquote",[n("p",[e._v("Pinia 正式成为 Vue 官方默认推荐的状态管理库")])]),n("h2",[e._v("安装")]),n("p",[n("a",{attrs:{href:"https://pinia.vuejs.org/"}},[e._v("官网")])]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v("yarn add pinia\n# or with npm\nnpm install pinia\n")])]),n("h2",[e._v("初始化 Pinia")]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v("import { createPinia } from 'pinia'\n\nconst pinia = createPinia()\npinia.use(SomePiniaPlugin) // 给 pinia 装插件\n\nconst app = createApp(App)\napp.use(pinia)\n")])]),n("blockquote",[n("p",[n("a",{attrs:{href:"https://pinia.vuejs.org/core-concepts/outside-component-usage.html#single-page-applications"}},[e._v("这里需要注意时间顺序：只有在调用 app.use(pinia) 之后才能调用 useXxxStore()")])])]),n("h2",[e._v("使用 Store")]),n("h3",[e._v("注意")]),n("ol",[n("li",[e._v("defineStore 接受一个 id，不同数据源的 id 必须是不同的")]),n("li",[e._v("不能将 useCounter() 的返回值解构，这会导致数据响应式的丢失")])]),n("h3",[e._v("写法一：")]),n("p",[e._v("更像原先的 vuex")]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v("// src/stores/counter.js\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counterStore', {\n  state: ()=> {\n    return {j: 0, k: 0}\n  }\n})\n\n// Counter.vue\nimport { useCounterStore } from 'path/to/src/stores/counterStore'\n\nexport default {\n  setup() {\n    const counterStore = useCounterStore()\n    // TODO 默认情况下可以直接这么更改，但是不推荐 // https://pinia.vuejs.org/core-concepts/state.html#accessing-the-state\n    counterStore.j ++\n\n    // 这里在视图里使用 counterStore.j 和 counterStore.k\n    // 但你不能解构 counterStore，因为解构会失去响应式，只能像下面这样解构：\n    const { j, k } = storeToRefs(counterStore)\n    return {\n      counterStore, j, k,\n    }\n  },\n}\n")])]),n("h5",[e._v("Store Getters")]),n("p",[e._v("getters 其实就是 store 的计算属性集合，而且 getter 不能是异步函数")]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v("export const useStore = defineStore('main', {\n  state: () => ({\n    counter: 0,\n  }),\n  getters: {\n    doubleCount(state) {\n      return state.counter * 2\n    },\n    doublePlusOne() {\n      return this.doubleCount + 1 // getter 访问另一个 getter 或者 state 可以用 this\n    },\n    getUserById: (state) => { // getter 可以返回一个函数，不过这会导致缓存失效\n      return (userId) => state.users.find((user) => user.id === userId)\n    },\n    otherGetter(state) { // 你还可以调用其他的 store\n      const otherStore = useOtherStore()\n      return state.localData + otherStore.data\n    },\n  },\n})\n// store.doubleCount 和 store.doublePlusOne 就可以直接当做属性使用了\n// store.getUserById(userId) 可以当做函数使用\n")])]),n("h5",[e._v("Store Actions")]),n("p",[e._v("action 其实就是 store 的 methods，而且可以是异步函数")]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v("export const useUserStore = defineStore('users', {\n  state: () => ({\n    userData: null,\n  }),\n  actions: {\n    async getUser(token) {\n      this.userData = await api.post({ token })\n    },\n  },\n})\n// 然后你就可以使用 userStore.getUser(token) 了\n")])]),n("h3",[e._v("写法二：")]),n("p",[e._v("推荐这种，符合 Vue3 setup 的编程模式，让结构更加扁平化")]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v("import { ref, computed } from 'vue';\nimport { defineStore } from 'pinia';\n\nexport const useUserStore = defineStore('users', () => {\n  const userData= ref({});\n  const getUser = async () => {\n    userData.value = await api.post({ token })\n  }\n\n  const userName = computed(() => userData.value.name)\n\n  return { userData, userName, getUser };\n});\n")])]),n("h2",[e._v("store.$patch(object | fn)")]),n("p",[e._v("批量更新")]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v("counterStore.$patch(\n   { name: 'pinia', age: counterStore.age + 1 }\n)\n\ncartStore.$patch((state) => {\n  state.items.push({ name: 'vuex', age: 18 })\n  state.hasChanged = true\n})\n")])]),n("h2",[e._v("store.$subscribe(fn)")]),n("p",[e._v("用于监听 state 的整体变化。")]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v("cartStore.$subscribe((mutation, state) => {\n  // import { MutationType } from 'pinia'\n  mutation.type // 'direct' | 'patch object' | 'patch function'\n  mutation.storeId\n  mutation.payload // 获取 $patch 接收到的参数\n\n  localStorage.setItem('cart', JSON.stringify(state))\n})\n")])]),n("blockquote",[n("p",[e._v("它有一个很方便的特性是会自动在组件卸载时注销，如果你不想要，可以在 $subscribe 第二个参数处传入 "),n("code",{pre:!0},[e._v("{detached: true}")]),e._v(" 选项。")])]),n("p",[e._v("你也可以使用 watch 达到类似的效果：")]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v("watch(\n  pinia.state,\n  (state) => {\n    localStorage.setItem('piniaState', JSON.stringify(state))\n  },\n  { deep: true }\n)\n")])]),n("h2",[e._v("store.$onAction()")]),n("p",[e._v("用于监控所有 action 的执行情况。")]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v('const unsubscribe = someStore.$onAction(\n  ({\n    name, // action 的名字\n    store, // store === someStore\n    args, // action 的实际参数\n    after, // action 成功之后执行 after\n    onError, // action 失败之后执行 onError\n  }) => {\n    const startTime = Date.now()\n    console.log(`开始执行 "${name}" 参数为 [${args.join(\', \')}].`)\n    after((result) => {\n      console.log(\n        `执行成功 "${name}" 用时 ${Date.now() - startTime}毫秒\\n结果为：${result}`\n      )\n    })\n    onError((error) => {\n      console.warn(\n        `执行失败 "${name}" 用时 ${Date.now() - startTime}毫秒\\n报错为：${error}.`\n      )\n    })\n  }\n)\n// $onAction 会在它所在组件卸载时自动销毁\n// 如果你将 $onAction 的第二个参数设置为 true，那么你需要自己调用 unsubscribe 来取消监听。\n')])]),n("h2",[e._v("store.$reset()")]),n("p",[e._v("你可以使用 counterStore.$reset() 重置 state")]),n("h2",[e._v("store.$state")]),n("pre",{pre:!0},[n("code",{pre:!0,attrs:{"v-pre":""}},[e._v("// 下面两句代码都能覆盖原有 state\nstore.$state = { counter: 666, name: 'Paimon' }\npinia.state.value = {} // 这句常用在 SSR\n")])])])])])}],s=n(1001),a={},p=(0,s.Z)(a,r,o,!1,null,null,null),u=p.exports}}]);